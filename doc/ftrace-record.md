% FTRACE-RECORD(1) Ftrace User Manuals
% Namhyung Kim <namhyung@gmail.com>
% March, 2015

NAME
====
ftrace-record - Run a command and record its trace data

SYNOPSIS
========
ftrace record [*options*] COMMAND [*command-options*]

DESCRIPTION
===========
This command runs COMMAND and gathers function trace from it, saves it into files under ftrace data directory - without displaying anything.

This data can then be inspected later on, using `ftrace-replay` or `ftrace-report` command.

OPTIONS
=======
-b *SIZE*, \--buffer=*SIZE*
:   Size of internal buffer which trace data will be saved.

-f *FILE*, \--file=*FILE*
:   Specify name of output trace data (directory).  Default is `ftrace.dir`.

-F *FUNC*, \--filter=*FUNC*
:   Set filter to trace selected functions only.  This option can be used more than once.  See *FILTERS*.

-N *FUNC*, \--notrace=*FUNC*
:   Set filter not trace selected functions only.  This option can be used more than once.  See *FILTERS*.

-T *TRG*, \--trigger=*TRG*
:   Set trigger on selected functions.  This option can be used more than once.  See *TRIGGERS*.

\--force
:   Allow to trace library source rather than executable itself.  When `ftrace-record` finds no mcount symbol (which is generated by compiler) in the executable it quits with an error message since it there's no need to run the program.  However it's possible one is only interested functions in a library, in this case she can use this option so ftrace can keep running the program.

-L *PATH*, \--library-path=*PATH*
:   Load necessary internal libraries from this path.  This is only for testing purpose.

\--logfile=FILE
:   Save log message to this file instead of stderr.

\--no-plthook
:   Do not record library function invocations.  The ftrace traces library calls by hooking dynamic linker's resolve function in the PLT.  One can disable it with this option.

-D *DEPTH*, \--depth=*DEPTH*
:   Set global trace limit in nesting level.

\--max-stack=*DEPTH*
:   Set max stack depth to trace function.  Default is 1024.

\--nop
:   Do not record any functions.  It's a no-op and only meaningful for performance comparison.

\--time
:   Print running time of children in time(1)-style.

-k, \--kernel
:   Trace kernel functions as well as user functions.  Only kernel entry/exit functions will be traced as if -D 1 was given.

-K, \--kernel-full
:   Trace kernel functions as well as user functions.  Kernel functions will be traced in full detail (ie. without depth limit unless explicitly given)

-H *HOST*, \--host=*HOST*
:   Send trace data to given host via network, not writing to files.  The `ftrace-recv` should be run on the host to receive the data.

\--port=*PORT*
:   When sending data to network (with -H option), use given port instead of the default port (8090).

\--color=*VAL*
:   Enable or disable color on the output.  Possible values are "yes", "no" and "auto".  The "auto" is default and turn on coloring if stdout is a terminal.

\--disabled
:   Start ftrace with tracing disabled.  This is only meaningful when used with 'trace_on' trigger.

FILTERS
=======
The ftrace support filtering only interested functions.  When ftrace is called it receives two types of function filter; opt-in filter with -F/\--filter option and opt-out filter with -N/\--notrace option.  These filters can be applied either record time or replay time.

The first one is an opt-in filter; By default, it doesn't trace anything and when it executes one of given functions it starts tracing.  Also when it returns from the given funciton, it stops again tracing.

For example, suppose a simple program which calls a(), b() and c() in turn.

    $ cat abc.c
    void c(void) {
        /* do nothing */
    }

    void b(void) {
        c();
    }

    void a(void) {
        b();
    }

    int main(void) {
        a();
        return 0;
    }

    $ gcc -o abc abc.c

Normally ftrace will trace all the functions from `main()` to `c()`.

    $ ftrace ./abc
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
                [ 1234] |     b() {
       3.880 us [ 1234] |       c();
       5.475 us [ 1234] |     } /* b */
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

But when `-F b` filter option is used, it'll not trace `main()` and `a()` but only `b()` and `c()`.

    $ ftrace record -F b ./abc
    $ ftrace replay
    # DURATION    TID     FUNCTION
                [ 1234] |     b() {
       3.880 us [ 1234] |       c();
       5.475 us [ 1234] |     } /* b */

The second type is an opt-out filter; By default, it trace everything and when it executes one of given functions it stops tracing.  Also when it returns from the given funciton, it starts tracing again.

In the above example, you can omit the function b() and its children with -N option.

    $ ftrace record -N b ./abc
    $ ftrace replay
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
       6.448 us [ 1234] |   a();
       8.631 us [ 1234] | } /* main */

In addition, you can limit the print nesting level with -D option.

    $ ftrace record -D 3 ./abc
    $ ftrace replay
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

In the above example, it prints functions up to 3 depth, so leaf function c() was omitted.  Note that the -D option works with -F option.

You can also set triggers to filtered functions.  See *TRIGGERS* section below for details.

When kernel function tracing is enabled, you can also set the filters on kernel functions.  It needs to mark the symbol with '@kernel' modifier.  Following example will show all user functions and (kernel) page fault handler.

    $ sudo ftrace -k -F '*page_fault@kernel' ./abc
    # DURATION    TID     FUNCTION
               [14721] | main() {
      7.713 us [14721] |   __do_page_fault();
      6.600 us [14721] |   __do_page_fault();
      6.544 us [14721] |   __do_page_fault();
               [14721] |   a() {
               [14721] |     b() {
               [14721] |       c() {
      0.860 us [14721] |         getpid();
      2.346 us [14721] |       } /* c */
      2.956 us [14721] |     } /* b */
      3.340 us [14721] |   } /* a */
     79.086 us [14721] | } /* main */


TRIGGERS
========
The ftrace support triggering some actions on selected function with or without filters.  Currently supported triggers are depth (for record and replay) and backtrace (for replay only).  The BNF for the trigger is like below:

    <trigger>  :=  <symbol> "@" <actions>
    <actions>  :=  <action>  | <action> "," <actions>
    <action>   :=  "depth=" <num> | "backtrace" | "trace_on" | "trace_off"

The depth trigger is to change filter depth during execution of the function.  It can be use to apply different filter depths for different functions.  And the backrace trigger is to print stack backtrace at replay time.

Following example shows how trigger works.  The global filter depth is 5, but function 'b' changed it to 1 so functions below the 'b' will not shown.

    $ ftrace record -D 5 -T 'b@depth=1' ./abc
    $ ftrace replay
    # DURATION    TID     FUNCTION
     138.494 us [ 1234] | __cxa_atexit();
                [ 1234] | main() {
                [ 1234] |   a() {
       5.475 us [ 1234] |     b();
       6.448 us [ 1234] |   } /* a */
       8.631 us [ 1234] | } /* main */

The 'backtrace' trigger is only meaningful in replay command.  The 'traceon' and 'traceoff' (you can omit '_' between 'trace' and 'on/off') controls whether ftrace records functions or not.

The 'recover' trigger is for some corner cases which the process accesses the callstack directly.  During tracing the v8 javascript engine, it kept get segfault in the garbage collection stage.  It was because the v8 interpretes the return address into compiled code object(?).  The 'recover' trigger restores the original return address at the function entry and reset to the ftrace's return hooking address again at the function exit.  I was managed to work around the segfault by setting 'recover' trigger on the related function (specifically ExitFrame::Iterate).

The ftrace trigger only works for user-level functions for now.


SEE ALSO
========
`ftrace`(1), `ftrace-replay`(1), `ftrace-report`(1)
